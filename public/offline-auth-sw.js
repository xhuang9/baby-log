/* eslint-disable no-restricted-globals */
/**
 * Offline Auth Bypass Service Worker
 *
 * This script is imported by the main service worker (generated by next-pwa).
 * It intercepts navigation requests to protected routes and allows offline access
 * when a valid session marker exists in IndexedDB.
 *
 * Note: Service workers require 'self' for the global scope, hence the eslint disable.
 *
 * @see .readme/planning/offline-auth-bypass.md
 */

// Database constants (must match src/lib/local-db/database.ts)
const DB_NAME = 'baby-log';
const DB_VERSION = 1;
const AUTH_SESSION_STORE = 'authSession';
const AUTH_SESSION_KEY = 'current';

// Protected routes that require auth (must match src/proxy.ts)
const PROTECTED_ROUTE_PATTERNS = [
  /^\/[a-z]{2}\/overview/,
  /^\/overview/,
  /^\/[a-z]{2}\/logs/,
  /^\/logs/,
  /^\/[a-z]{2}\/insights/,
  /^\/insights/,
  /^\/[a-z]{2}\/settings/,
  /^\/settings/,
  /^\/[a-z]{2}\/account\/bootstrap/,
  /^\/account\/bootstrap/,
];

// Routes that should NOT be intercepted (auth pages)
const AUTH_ROUTE_PATTERNS = [
  /^\/[a-z]{2}\/sign-in/,
  /^\/sign-in/,
  /^\/[a-z]{2}\/sign-up/,
  /^\/sign-up/,
];

/**
 * Check if a pathname matches protected routes
 */
function isProtectedRoute(pathname) {
  // Skip auth routes
  for (const pattern of AUTH_ROUTE_PATTERNS) {
    if (pattern.test(pathname)) {
      return false;
    }
  }

  // Check protected routes
  for (const pattern of PROTECTED_ROUTE_PATTERNS) {
    if (pattern.test(pathname)) {
      return true;
    }
  }

  return false;
}

/**
 * Open IndexedDB and get auth session
 * Returns null if no valid session exists
 */
function getAuthSessionFromIndexedDB() {
  return new Promise((resolve) => {
    try {
      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onerror = () => {
        console.warn('[offline-auth-sw] IndexedDB open error');
        resolve(null);
      };

      request.onsuccess = (event) => {
        const db = event.target.result;

        // Check if authSession store exists
        if (!db.objectStoreNames.contains(AUTH_SESSION_STORE)) {
          console.warn('[offline-auth-sw] authSession store not found');
          db.close();
          resolve(null);
          return;
        }

        const transaction = db.transaction(AUTH_SESSION_STORE, 'readonly');
        const store = transaction.objectStore(AUTH_SESSION_STORE);
        const getRequest = store.get(AUTH_SESSION_KEY);

        getRequest.onerror = () => {
          console.warn('[offline-auth-sw] Failed to get auth session');
          db.close();
          resolve(null);
        };

        getRequest.onsuccess = () => {
          const session = getRequest.result;
          db.close();

          if (!session) {
            resolve(null);
            return;
          }

          // Check expiration
          if (session.expiresAt) {
            const expiresAt = new Date(session.expiresAt);
            const now = new Date();
            if (now > expiresAt) {
              console.warn('[offline-auth-sw] Auth session expired');
              resolve(null);
              return;
            }
          }

          resolve(session);
        };
      };

      // Handle upgrade needed (database structure changed)
      request.onupgradeneeded = () => {
        // Don't create stores here, just close
        resolve(null);
      };
    } catch (error) {
      console.error('[offline-auth-sw] Error accessing IndexedDB:', error);
      resolve(null);
    }
  });
}

/**
 * Handle navigation requests to protected routes when offline
 */
async function handleOfflineNavigation(request) {
  const url = new URL(request.url);

  // Check if user has a valid offline session
  const session = await getAuthSessionFromIndexedDB();

  if (session) {
    // User has valid session - try to serve from cache
    // Try to get cached response for this navigation
    const cache = await caches.open('others');
    const cachedResponse = await cache.match(request, { ignoreSearch: true });

    if (cachedResponse) {
      return cachedResponse;
    }

    // Try to match against the base path (for dynamic routes)
    const basePath = url.pathname.split('/').slice(0, 3).join('/');
    const baseRequest = new Request(url.origin + basePath);
    const baseCachedResponse = await cache.match(baseRequest, { ignoreSearch: true });

    if (baseCachedResponse) {
      return baseCachedResponse;
    }

    // Fallback: try to serve the offline shell from start-url cache
    const startUrlCache = await caches.open('start-url');
    const shellResponse = await startUrlCache.match('/');

    if (shellResponse) {
      return shellResponse;
    }

    // Last resort: serve offline page if available
    const offlineResponse = await cache.match('/offline.html');
    if (offlineResponse) {
      return offlineResponse;
    }
  }

  // No valid session or no cached content - let it fail naturally
  // This will show the browser's offline page
  return fetch(request);
}

/**
 * Fetch event listener for navigation interception
 * This is called by the main service worker for navigation requests
 */
self.addEventListener('fetch', (event) => {
  const request = event.request;

  // Only handle navigation requests
  if (request.mode !== 'navigate') {
    return;
  }

  const url = new URL(request.url);

  // Only handle protected routes
  if (!isProtectedRoute(url.pathname)) {
    return;
  }

  // Check if we're offline
  if (navigator.onLine) {
    // Online - let the normal flow handle it
    return;
  }

  // Offline + protected route - handle with offline auth logic
  event.respondWith(handleOfflineNavigation(request));
});
